Description: Fix spelling mistakes
 Those were found with codespell
Author: Frederic Bonnard <frediz@linux.vnet.ibm.com>
Bug: https://github.com/sphde/sphde/pull/18
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/doc/libsphde-doxygen-sph.doxy
+++ b/doc/libsphde-doxygen-sph.doxy
@@ -282,7 +282,7 @@
 # causing a significant performance penality.
 # If the system has enough physical memory increasing the cache will improve the
 # performance by keeping more symbols in memory. Note that the value works on
-# a logarithmic scale so increasing the size by one will rougly double the
+# a logarithmic scale so increasing the size by one will roughly double the
 # memory usage. The cache size is given by this formula:
 # 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0,
 # corresponding to a cache size of 2^16 = 65536 symbols
--- a/src/bitv.c
+++ b/src/bitv.c
@@ -400,7 +400,7 @@
    verifies:
 	That alloc_units fit within a bitv_word
    returns:
-	0 if the deallocation was sucessful from this bitv_word
+	0 if the deallocation was successful from this bitv_word
 	or nonzero if something failed
 */
   bitv_word req_msk = bitv_units_to_mask (alloc_units);
@@ -412,7 +412,7 @@
   req_msk >>= offset;
   prv_msk = __sync_fetch_and_or (bvec, req_msk);
   /* Insure that we are deallocating units that were previously
-     allocated. If so the logical and of the orginal unit mask
+     allocated. If so the logical and of the orignal unit mask
      and the requested mask should be 0s. */
   prv_msk &= req_msk;
 #ifdef PRINT_DEBUG
@@ -431,7 +431,7 @@
    verifies:
 	That size fits within a bitv_word
    returns:
-	0 if the deallocation was sucessful from this bitv_word
+	0 if the deallocation was successful from this bitv_word
 	or nonzero if something failed
 */
   size_t alloc_units = bitv_round_unit (cb, size);
@@ -460,7 +460,7 @@
 	That an end mark is set between the starting offset and the
 	end of end makr vector.
    returns:
-	0 if the deallocation was sucessful from this bitv_word
+	0 if the deallocation was successful from this bitv_word
 	or nonzero if something failed
 */
   int rc = -1;
--- a/src/bitv.h
+++ b/src/bitv.h
@@ -69,7 +69,7 @@
 
 /* 
    Allocate size (rounded up to alloc_units) from the bit vector.
-   The resulting allocation is alligned to boundary specified.
+   The resulting allocation is aligned to boundary specified.
 
    Assumes:
 	cb has been initialized by bitv_init()
@@ -94,7 +94,7 @@
    verifies:
 	That size fits within a bitv_word
    returns:
-	0 if the deallocation was sucessful from this bitv_word
+	0 if the deallocation was successful from this bitv_word
 	or nonzero if something failed
 */
 extern __C__ int
@@ -120,7 +120,7 @@
 /* 
    Allocate size (rounded up to alloc_units) from the bit vector (*bvec)
    then mark the last unit of the allocation (*endvec). The resulting
-   allocation is alligned to boundary specified.
+   allocation is aligned to boundary specified.
 
    Assumes:
 	cb has been initialized by bitv_init()
@@ -157,7 +157,7 @@
 	That an end mark is set between the starting offset and the
 	end of end makr vector.
    returns:
-	0 if the deallocation was sucessful from this bitv_word
+	0 if the deallocation was successful from this bitv_word
 	or nonzero if something failed
 */
 extern __C__ size_t
--- a/src/bitv_priv.h
+++ b/src/bitv_priv.h
@@ -132,7 +132,7 @@
 	That an end mark is set between the starting offset and the
 	end of end makr vector.
    returns:
-	Non-zero allocation size in bytes 0 if the deallocation was sucessful from this bitv_word
+	Non-zero allocation size in bytes 0 if the deallocation was successful from this bitv_word
 	or zero of  no allocation
 */
 	size_t alloc_units = 0;
@@ -160,7 +160,7 @@
 	That an end mark is set between the starting offset and the
 	end of end makr vector.
    returns:
-	Non-zero allocation size in bytes 0 if the deallocation was sucessful from this bitv_word
+	Non-zero allocation size in bytes 0 if the deallocation was successful from this bitv_word
 	or zero of  no allocation
 */
 	size_t alloc_units = 0;
--- a/src/freenode.c
+++ b/src/freenode.c
@@ -7,7 +7,7 @@
  * 
  * Contributors:
  *     IBM Corporation, Steven Munroe      - initial API and implementation
- *     IBM Corporation, Adhemerval Zanella - C code convertion
+ *     IBM Corporation, Adhemerval Zanella - C code conversion
  */
 
 // utility class for managing a heap
--- a/src/sasatom.h
+++ b/src/sasatom.h
@@ -239,7 +239,7 @@
 }
 
 /*!
- * The function tried to lock \a lock. If the operation is successfull the
+ * The function tried to lock \a lock. If the operation is successful the
  * function return 0 or 1 otherwise.
  */
 static inline int
--- a/src/sascompoundheap.h
+++ b/src/sascompoundheap.h
@@ -174,7 +174,7 @@
  * \brief Create a new SAS Compound Heap with \a heap_size size and \a 
  * page_size page size.
  *
- * Similiar to ::SASCompoundHeapCreate but with additional option to set the
+ * Similar to ::SASCompoundHeapCreate but with additional option to set the
  * internal page size.
  *
  * @param heap_size Size of the Compound Heap to create.
@@ -188,7 +188,7 @@
 /*!
  * \brief Create a new non expanding SAS Compound heap with \a heap_size.
  *
- * Similiar to ::SASCompoundHeapCreate but without the option to expand when
+ * Similar to ::SASCompoundHeapCreate but without the option to expand when
  * load factor allows it.
  *
  * @param heap_size Size of the Compound Heap to create.
@@ -390,7 +390,7 @@
 /*!
  * \brief Destroy the SAS Compound Heap \a heap.
  *
- * Similiar to ::SASCompoundHeapDestroy but do not hold the write lock on the
+ * Similar to ::SASCompoundHeapDestroy but do not hold the write lock on the
  * memory address.
  *
  * @param heap Handle of the SASCompoundHeap_t.
--- a/src/sasindex.cpp
+++ b/src/sasindex.cpp
@@ -671,7 +671,7 @@
 }
 
 /* This section handles allocation of spill heaps and adds them to the 
- * spillList.  The preference is to allocate a spill heap withing the same
+ * spillList.  The preference is to allocate a spill heap within the same
  * compoundHead as the near object.  If space is not available in the near
  * compoundHeap it will allocate from another compoundHeap in the expanded
  * list.  If the local spill list is full or the a spill heap can not be
--- a/src/sasindex.h
+++ b/src/sasindex.h
@@ -146,7 +146,7 @@
  * \brief Create a new expanding SAS B-Tree with \a heap_size size
  * and \a page_size node size.
  *
- * Similiar to ::SASIndexCreate but with additional option to set the
+ * Similar to ::SASIndexCreate but with additional option to set the
  * internal node page size.
  *
  * @param block_size Size of the B-Tree to create.
--- a/src/sasindexnode.cpp
+++ b/src/sasindexnode.cpp
@@ -667,7 +667,7 @@
 
 // we must return
 // a combined "found" and "position" result. If "found"
-// result is >=0 and == "postion". Otherwise result < 0 and
+// result is >=0 and == "position". Otherwise result < 0 and
 // "position == result + 256;
 short
 SASIndexNodeSearchNode (SASIndexNode_t header, SASIndexKey_t * target)
@@ -1624,7 +1624,7 @@
 #endif
 
   if (q != NULL)
-    {				// dispose of q, since it is no longer accessable 
+    {				// dispose of q, since it is no longer accessible 
 #ifdef __SASDebugPrint__
       sas_printf ("Remove: delete branch for pos=%hd @%p\n", pos, q);
 #endif
@@ -1968,7 +1968,7 @@
 	    {
 	      found = SASIndexNodeRecDelete (q, node->keys[k], lock_on);
 #if __SASDebugPrint__ > 1
-	      sas_printf ("RecDelete after Sucessor found=%d\n", found);
+	      sas_printf ("RecDelete after Successor found=%d\n", found);
 	      sas_printf ("RecDelete: subtree=");
 	      SASIndexNodePrint (header);
 	      sas_printf ("\n");
--- a/src/saslockl.cpp
+++ b/src/saslockl.cpp
@@ -311,8 +311,8 @@
       cout << "Number of lock objects created in this slot: "
         << count << endl;
       int k = 1;
-      cout << '\t' << "LOCK #" << '\t' << "USEAGE" << endl;
-      // Run the list to get useage info on each lock; also check if lock is in
+      cout << '\t' << "LOCK #" << '\t' << "USAGE" << endl;
+      // Run the list to get usage info on each lock; also check if lock is in
       // a locked state.
       for (iteratorPtr = headPtr;
            iteratorPtr != NULL;
--- a/src/sasmlock.cpp
+++ b/src/sasmlock.cpp
@@ -253,9 +253,9 @@
    printf ("Number of table slots with items: %u\n", tallyOfSlotsWithLocks);
    printf ("Highest item density: %u\n", lockDensity);
    #ifdef collectstats
-   cout << "Highest useage count = " << runningHighestUseage
+   cout << "Highest usage count = " << runningHighestUseage
      << " in slot #" << highestUseageSlot << endl;
-   cout << "Lowest useage count = " << runningLowestUseage
+   cout << "Lowest usage count = " << runningLowestUseage
      << " in slot #" << lowestUseageSlot << endl;
    #endif
 }
--- a/src/sasmlock.h
+++ b/src/sasmlock.h
@@ -43,10 +43,10 @@
 *
 *       -This class also enables collection and printing of lock table
 *       statistics, such as distribution info (i.e., load factor) and
-*       useage.  The printHighLevelStats() method prints load factor
+*       usage.  The printHighLevelStats() method prints load factor
 *       info and other totals.  printDetailedStats() prints info
 *       on each table entry containing one or more locks, and also
-*       prints out how many times each lock was locked (useage).
+*       prints out how many times each lock was locked (usage).
 *       In order to collect and print this detailed information, the
 *       user must compile with "collectstats" defined.
 *
--- a/src/sassimpleheap.h
+++ b/src/sassimpleheap.h
@@ -133,7 +133,7 @@
  * @param free_block Memory block previously allocated using SASSimpleHeapAlloc
  * function.
  * @param alloc_size Size in bytes of the allocated block size.
- * @return 0 if the block was sucessfully freed, -1 if \a alloc_size is
+ * @return 0 if the block was successfully freed, -1 if \a alloc_size is
  * incorrect, or -2 if \a heap is not a SAS_RUNTIME_SIMPLEHEAP.
  */
 extern __C__ int 
@@ -174,7 +174,7 @@
  *
  * @param memAddr Handle of a SAS Simple Heap.
  * @param allocSize Size in bytes of the allocated block size.
- * @return 0 if the block was sucessfully freed, -1 if \a alloc_size is
+ * @return 0 if the block was successfully freed, -1 if \a alloc_size is
  * incorrect, or -2 if \a heap is not a SAS_RUNTIME_SIMPLEHEAP.
  */
 extern __C__ void
@@ -183,7 +183,7 @@
 /*!
  * \brief Destroy a SASSimpleHeap_t and free the shared storage block.
  *
- * Similiar to ::SASSimpleHeapDestroy but do not hold any write lock.
+ * Similar to ::SASSimpleHeapDestroy but do not hold any write lock.
  *
  * @param heap handle of the SASSimpleHeap_t to be destroyed.
  * @return a 0 value indicates success, otherwise failure.
@@ -226,7 +226,7 @@
  * @param free_block Memory block previously allocated using SASSimpleHeapAlloc
  * function.
  * @param alloc_size Size in bytes of the allocated block size.
- * @return 0 if the block was sucessfully freed, -1 if \a alloc_size is
+ * @return 0 if the block was successfully freed, -1 if \a alloc_size is
  * incorrect, or -2 if \a heap is not a SAS_RUNTIME_SIMPLEHEAP.
  */
 extern __C__ int 
@@ -254,7 +254,7 @@
  *
  * @param memAddr Handle of a SAS Simple Heap.
  * @param allocSize Size in bytes of the allocated block size.
- * @return 0 if the block was sucessfully freed, -1 if \a alloc_size is
+ * @return 0 if the block was successfully freed, -1 if \a alloc_size is
  * \a alloc_size if incorrect, or -2 if \a heap is not a SAS_RUNTIME_SIMPLEHEAP.
  */
 extern __C__ void
--- a/src/sasstringbtree.cpp
+++ b/src/sasstringbtree.cpp
@@ -731,7 +731,7 @@
 }
 
 /* This section handles allocation of spill heaps and adds them to the 
- * spillList.  The preference is to allocate a spill heap withing the same
+ * spillList.  The preference is to allocate a spill heap within the same
  * compoundHead as the near object.  If space is not available in the near
  * compoundHeap it will allocate from another compoundHeap in the expanded
  * list.  If the local spill list is full or the a spill heap can not be
--- a/src/sasstringbtree.h
+++ b/src/sasstringbtree.h
@@ -153,7 +153,7 @@
  * \brief Create a new expanding SAS B-Tree with \a heap_size size
  * and \a page_size node size.
  *
- * Similiar to ::SASStringBTreeCreate but with additional option to set the
+ * Similar to ::SASStringBTreeCreate but with additional option to set the
  * internal node page size.
  *
  * @param block_size Size of the B-Tree to create.
@@ -684,7 +684,7 @@
  *
  * Similar to ::SASStringBTreeNearAlloc but this function holds no lock.
  *
- * @param nearObj Memory addres of the handle to the SASStringBTree_t.
+ * @param nearObj Memory address of the handle to the SASStringBTree_t.
  * @return A new SASStringBTreeNode_t handle or 0 if creation fails.
  */
 extern __C__ SASStringBTreeNode_t
--- a/src/sasstringbtreenode.cpp
+++ b/src/sasstringbtreenode.cpp
@@ -681,7 +681,7 @@
 
 // we must return
 // a combined "found" and "position" result. If "found"
-// result is >=0 and == "postion". Otherwise result < 0 and
+// result is >=0 and == "position". Otherwise result < 0 and
 // "position == result + 256;
 short
 SASStringBTreeNodeSearchNode (SASStringBTreeNode_t header, char *target)
@@ -1617,7 +1617,7 @@
 #endif
 
   if (q != NULL)
-    {				// dispose of q, since it is no longer accessable 
+    {				// dispose of q, since it is no longer accessible 
 #ifdef __SASDebugPrint__
       sas_printf ("Remove: delete branch for pos=%hd @%p\n", pos, q);
 #endif
@@ -1966,7 +1966,7 @@
 	    {
 	      found = SASStringBTreeNodeRecDelete (q, node->keys[k], lock_on);
 #if __SASDebugPrint__ > 1
-	      sas_printf ("RecDelete after Sucessor found=%d\n", found);
+	      sas_printf ("RecDelete after Successor found=%d\n", found);
 	      sas_printf ("RecDelete: subtree=");
 	      SASStringBTreeNodePrint (header);
 	      sas_printf ("\n");
--- a/src/sasstringbtreenode.h
+++ b/src/sasstringbtreenode.h
@@ -24,7 +24,7 @@
  *
  * The basic function to allocate entries is ::SASStringBTreeAlloc and it
  * returns a ::SASStringBTreeNode_t (mode info on sasstringbtreenode.h). The
- * function ::SASStringBTreeNearAlloc is similiar, but it accepts a memory
+ * function ::SASStringBTreeNearAlloc is similar, but it accepts a memory
  * pointer to SASStringBTree_t as argument.
  *
  * Once a SAS B-Tree is created its member can be accessed using the functions
@@ -254,7 +254,7 @@
 /*!
  * \brief Destroy the SAS B-Tree element \a heap.
  *
- * Similiar to ::SASStringBTreeNodeDestroy but the function holds no lock.
+ * Similar to ::SASStringBTreeNodeDestroy but the function holds no lock.
  *
  * @param heap Handle of the SASStringBTreeNode_t to be destroyed.
  */
--- a/src/sphgtod.h
+++ b/src/sphgtod.h
@@ -20,7 +20,7 @@
  *
  * This API is intended to support post processing time stamps
  * (including those generated by SPHLFLogger_t and SPHSinglePCQueue_t)
- * into gettimeofday() epoch and related formated time values.
+ * into gettimeofday() epoch and related formatted time values.
  *
  * It is not intended as an exact replacement for gettimeofday()
  * because it may not include any NTP corrections for example,
@@ -59,7 +59,7 @@
  * similar to "uptime" we need to allow for logs that persist across
  * reboot. By saving this conversion factor in the log we can use it
  * during post processing of the log to get the corrected gettimeofday
- * value for formated time values.
+ * value for formatted time values.
  *
  * This allow the logger to run as fast as possible by postponing the
  * timebase to gettimeofday conversion until post processing.
@@ -77,7 +77,7 @@
  * similar to "uptime" we need to allow for logs that persist across
  * reboot. By saving the conversion factor (via sphget_gtod_conv_factor())
  * in the log we can use it (via this API) during post processing of
- * the log to get the corrected gettimeofday value for formated time
+ * the log to get the corrected gettimeofday value for formatted time
  * values.
  *
  * @param tv address of the struct timeval buffer.
--- a/src/sphlflogger.h
+++ b/src/sphlflogger.h
@@ -531,7 +531,7 @@
 *	The resulting entry handle can be used to read the contents of
 *	the Logger entry.
 *
-*	@param iterator Handle asociated with a Logger.
+*	@param iterator Handle associated with a Logger.
 *	@param handlespace Address of local area that will be initialied as a
 *	SPHLFLoggerHandle_t for the allocated entry.
 *	@return a pointer to the handle space provided, initialized as a
--- a/src/sphlogportal.h
+++ b/src/sphlogportal.h
@@ -31,7 +31,7 @@
 *
 *	A portal is used when the required capacity for logger entries
 *	exceeds that posible for a single logger. Or we need to support
-*	rolling/continous logs over a long period of time. By switching out
+*	rolling/continuous logs over a long period of time. By switching out
 *	filled loggers with new/empty loggers, logging can continue indeffinitely.
 */
 
@@ -244,7 +244,7 @@
 *	the next logger allocated to this portal.
 *	If we are at the end of the list of allocated loggers we are done.
 *
-*	@param iterator Handle asociated with a Log Portal.
+*	@param iterator Handle associated with a Log Portal.
 *	@param handlespace Address of local area that will be initialied as a
 *	SPHLFLoggerHandle_t for the allocated entry.
 *	@return the address of the provided handlespace or NULL.
--- a/src/tests/sphlflogger_t.c
+++ b/src/tests/sphlflogger_t.c
@@ -91,7 +91,7 @@
 	}
       else
 	{
-	  printf ("lflogger_basic_test SPHLFLoggerEmpty(%p) false, suceeds\n",
+	  printf ("lflogger_basic_test SPHLFLoggerEmpty(%p) false, succeeds\n",
 		  lfLog);
 	}
 
@@ -253,7 +253,7 @@
 	}
       else
 	{
-	  printf ("lflogger_basic_test SPHLFLoggerFull(%p) true, suceeds\n",
+	  printf ("lflogger_basic_test SPHLFLoggerFull(%p) true, succeeds\n",
 		  lfLog);
 	}
     }
@@ -334,7 +334,7 @@
 	}
       else
 	{
-	  printf ("lflogger_basic_test SPHLFLoggerEmpty(%p) false, suceeds\n",
+	  printf ("lflogger_basic_test SPHLFLoggerEmpty(%p) false, succeeds\n",
 		  lfLog);
 	}
 
@@ -452,7 +452,7 @@
 	}
       else
 	{
-	  printf ("lflogger_basic_test SPHLFLoggerFull(%p) true, suceeds\n",
+	  printf ("lflogger_basic_test SPHLFLoggerFull(%p) true, succeeds\n",
 		  lfLog);
 	}
     }
@@ -627,7 +627,7 @@
       else
 	{
 	  printf
-	    ("lflogger_timestamp_test SPHLFLoggerEmpty(%p) false, suceeds\n",
+	    ("lflogger_timestamp_test SPHLFLoggerEmpty(%p) false, succeeds\n",
 	     lfLog);
 	}
 
@@ -1107,7 +1107,7 @@
       else
 	{
 	  printf
-	    ("lflogger_timestamp_test SPHLFLoggerFull(%p) true, suceeds\n",
+	    ("lflogger_timestamp_test SPHLFLoggerFull(%p) true, succeeds\n",
 	     lfLog);
 	}
     }
@@ -3008,7 +3008,7 @@
       valc = SPHLFlogEntryGetNextChar (&handle1);
       if (valc == 'a')
 	{
-	  printf ("sucess SPHLFlogEntryGetNextChar(%p) returned %c\n",
+	  printf ("success SPHLFlogEntryGetNextChar(%p) returned %c\n",
 		  &handle1, valc);
 	}
       else
@@ -3026,7 +3026,7 @@
       valsi = SPHLFlogEntryGetNextShort (&handle1);
       if (valsi == 1234)
 	{
-	  printf ("sucess SPHLFlogEntryGetNextShort(%p) returned %hd\n",
+	  printf ("success SPHLFlogEntryGetNextShort(%p) returned %hd\n",
 		  &handle1, valsi);
 	}
       else
@@ -3043,7 +3043,7 @@
       valsi = SPHLFlogEntryGetNextShort (&handle1);
       if (valsi == 12345)
 	{
-	  printf ("sucess SPHLFlogEntryGetNextShort(%p) returned %hd\n",
+	  printf ("success SPHLFlogEntryGetNextShort(%p) returned %hd\n",
 		  &handle1, valsi);
 	}
       else
@@ -3060,7 +3060,7 @@
       valc = SPHLFlogEntryGetNextChar (&handle1);
       if (valc == 'b')
 	{
-	  printf ("sucess SPHLFlogEntryGetNextChar(%p) returned %c\n",
+	  printf ("success SPHLFlogEntryGetNextChar(%p) returned %c\n",
 		  &handle1, valc);
 	}
       else
@@ -3078,7 +3078,7 @@
       vali = SPHLFlogEntryGetNextInt (&handle1);
       if (vali == 123456)
 	{
-	  printf ("sucess SPHLFlogEntryGetNextInt(%p) returned %d\n",
+	  printf ("success SPHLFlogEntryGetNextInt(%p) returned %d\n",
 		  &handle1, vali);
 	}
       else
@@ -3095,7 +3095,7 @@
       vali = SPHLFlogEntryGetNextInt (&handle1);
       if (vali == 1234567)
 	{
-	  printf ("sucess SPHLFlogEntryGetNextInt(%p) returned %d\n",
+	  printf ("success SPHLFlogEntryGetNextInt(%p) returned %d\n",
 		  &handle1, vali);
 	}
       else
@@ -3112,7 +3112,7 @@
       valc = SPHLFlogEntryGetNextChar (&handle1);
       if (valc == 'c')
 	{
-	  printf ("sucess SPHLFlogEntryGetNextChar(%p) returned %c\n",
+	  printf ("success SPHLFlogEntryGetNextChar(%p) returned %c\n",
 		  &handle1, valc);
 	}
       else
@@ -3130,7 +3130,7 @@
       valll = SPHLFlogEntryGetNextLongLong (&handle1);
       if (valll == 1234567890LL)
 	{
-	  printf ("sucess SPHLFlogEntryGetNextLongLong(%p) returned %lld\n",
+	  printf ("success SPHLFlogEntryGetNextLongLong(%p) returned %lld\n",
 		  &handle1, valll);
 	}
       else
@@ -3147,7 +3147,7 @@
       valll = SPHLFlogEntryGetNextLongLong (&handle1);
       if (valll == 12345678901LL)
 	{
-	  printf ("sucess SPHLFlogEntryGetNextLongLong(%p) returned %lld\n",
+	  printf ("success SPHLFlogEntryGetNextLongLong(%p) returned %lld\n",
 		  &handle1, valll);
 	}
       else
@@ -3164,7 +3164,7 @@
       valc = SPHLFlogEntryGetNextChar (&handle1);
       if (valc == 'd')
 	{
-	  printf ("sucess SPHLFlogEntryGetNextChar(%p) returned %c\n",
+	  printf ("success SPHLFlogEntryGetNextChar(%p) returned %c\n",
 		  &handle1, valc);
 	}
       else
@@ -3182,7 +3182,7 @@
       valp = SPHLFlogEntryGetNextPtr (&handle1);
       if (valp == &handle0)
 	{
-	  printf ("sucess SPHLFlogEntryGetNextPtr(%p) returned %p\n",
+	  printf ("success SPHLFlogEntryGetNextPtr(%p) returned %p\n",
 		  &handle1, valp);
 	}
       else
@@ -3199,7 +3199,7 @@
       valp = SPHLFlogEntryGetNextPtr (&handle1);
       if (valp == &handle1)
 	{
-	  printf ("sucess SPHLFlogEntryGetNextPtr(%p) returned %p\n",
+	  printf ("success SPHLFlogEntryGetNextPtr(%p) returned %p\n",
 		  &handle1, valp);
 	}
       else
@@ -3216,7 +3216,7 @@
       valc = SPHLFlogEntryGetNextChar (&handle1);
       if (valc == 'e')
 	{
-	  printf ("sucess SPHLFlogEntryGetNextChar(%p) returned %c\n",
+	  printf ("success SPHLFlogEntryGetNextChar(%p) returned %c\n",
 		  &handle1, valc);
 	}
       else
@@ -3235,7 +3235,7 @@
       valf = SPHLFlogEntryGetNextFloat (&handle1);
       if (valf == testf)
 	{
-	  printf ("sucess SPHLFlogEntryGetNextFloat(%p) returned %f\n",
+	  printf ("success SPHLFlogEntryGetNextFloat(%p) returned %f\n",
 		  &handle1, valf);
 	}
       else
@@ -3253,7 +3253,7 @@
       valf = SPHLFlogEntryGetNextFloat (&handle1);
       if (valf == testf)
 	{
-	  printf ("sucess SPHLFlogEntryGetNextFloat(%p) returned %f\n",
+	  printf ("success SPHLFlogEntryGetNextFloat(%p) returned %f\n",
 		  &handle1, valf);
 	}
       else
@@ -3270,7 +3270,7 @@
       valc = SPHLFlogEntryGetNextChar (&handle1);
       if (valc == 'f')
 	{
-	  printf ("sucess SPHLFlogEntryGetNextChar(%p) returned %c\n",
+	  printf ("success SPHLFlogEntryGetNextChar(%p) returned %c\n",
 		  &handle1, valc);
 	}
       else
@@ -3289,7 +3289,7 @@
       vald = SPHLFlogEntryGetNextDouble (&handle1);
       if (vald == testd)
 	{
-	  printf ("sucess SPHLFlogEntryGetNextDouble(%p) returned %f\n",
+	  printf ("success SPHLFlogEntryGetNextDouble(%p) returned %f\n",
 		  &handle1, vald);
 	}
       else
@@ -3307,7 +3307,7 @@
       vald = SPHLFlogEntryGetNextDouble (&handle1);
       if (vald == testd)
 	{
-	  printf ("sucess SPHLFlogEntryGetNextDouble(%p) returned %f\n",
+	  printf ("success SPHLFlogEntryGetNextDouble(%p) returned %f\n",
 		  &handle1, vald);
 	}
       else
@@ -3325,7 +3325,7 @@
       valstr = SPHLFlogEntryGetNextString (&handle1);
       if (!strcmp (valstr, "mnopqrstuvwxyz"))
 	{
-	  printf ("sucess SPHLFlogEntryGetNextString(%p) returned %s\n",
+	  printf ("success SPHLFlogEntryGetNextString(%p) returned %s\n",
 		  &handle1, valstr);
 	}
       else
--- a/src/tests/sphlockfreeheap_t.c
+++ b/src/tests/sphlockfreeheap_t.c
@@ -887,7 +887,7 @@
 		lfHeap);
 	    rc++;
 	} else {
-	    printf("lockfree_basic_test SPHLockFreeHeapEmpty(%p) suceeds\n",
+	    printf("lockfree_basic_test SPHLockFreeHeapEmpty(%p) succeeds\n",
 		lfHeap);
 	}
 
@@ -1066,7 +1066,7 @@
 		lfHeap);
 	    rc++;
 	} else {
-	    printf("lockfree_basic_test SPHLockFreeHeapEmpty(%p) suceeds\n",
+	    printf("lockfree_basic_test SPHLockFreeHeapEmpty(%p) succeeds\n",
 		lfHeap);
 	}
 
@@ -1389,7 +1389,7 @@
 		lfHeap);
 	    rc++;
 	} else {
-	    printf("lockfree_near_test SPHLockFreeHeapEmpty(%p) suceeds\n",
+	    printf("lockfree_near_test SPHLockFreeHeapEmpty(%p) succeeds\n",
 		lfHeap);
 	}
 
